[{"title":"Iris","type":0,"sectionRef":"#","url":"/Iris/docs/intro","content":"Iris Iris is an Immediate mode GUI Library for Roblox, Based on Dear ImGui. It solves the same problems as Dear ImGui. It is fast, portable, and self-contained.","keywords":""},{"title":"Events","type":0,"sectionRef":"#","url":"/Iris/docs/events","content":"Events Each widget has a number of events connected to it. You can see these events on the API page. Certain events will happen once, such as a window being collapsed or a button being clicked. Other events can be continuous, such as a widget being hovered. Each event is a function which returns a boolean value for whether the event has happened that frame or not. To listen to an event, use the following: local button = Iris.Button({ &quot;Please click me!&quot; }) if button.clicked() then print(&quot;The button was clicked!&quot;) end Events will fire the frame after the initial action happened. This is so that any changes caused by that event can propogate visually. For example on a checkbox: [Frames 1 - 60]The mouse is elsewhere. [Frames 61 - 80]The user is moving their moues towards the checkbox. [Frame 81 - 100]The mouse enters the checkbox. The .hovered() event fires because this event will fire on the frame. [Frame 101]The user presses MouseButton1 down on the checkbox. [Frame 102]The user releases the MouseButton1. [Frame 103]The checkbox tick appears. The .checked() event fires.","keywords":""},{"title":"Plot","type":0,"sectionRef":"#","url":"/Iris/api/Plot","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Plot","url":"/Iris/api/Plot#properties","content":" "},{"title":"ProgressBar​","type":1,"pageTitle":"Plot","url":"/Iris/api/Plot#ProgressBar","content":"Widget HasState &lt;/&gt; Plot.ProgressBar: Iris.PrograssBar A progress bar line with a state value to show the current state. hasChildren = false hasState = true Arguments = { Text: string? = &quot;Progress Bar&quot;, Format: string? = nil -- optional to override with a custom progress such as `29/54` } Events = { hovered: () -&gt; boolean, changed: () -&gt; boolean } States = { progress: State&lt;number&gt;? }  "},{"title":"Format","type":0,"sectionRef":"#","url":"/Iris/api/Format","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#properties","content":" "},{"title":"Separator​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Separator","content":"Widget &lt;/&gt; Format.Separator: Iris.Separator A vertical or horizonal line, depending on the context, which visually seperates widgets. hasChildren = false hasState = false   "},{"title":"Indent​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Indent","content":"Widget HasChildren &lt;/&gt; Format.Indent: Iris.Indent Indents its child widgets. hasChildren = true hasState = false Arguments = { Width: number? = Iris._config.IndentSpacing -- indent width ammount. }   "},{"title":"SameLine​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#SameLine","content":"Widget HasChildren &lt;/&gt; Format.SameLine: Iris.SameLine Positions its children in a row, horizontally. hasChildren = true hasState = false Arguments = { Width: number? = Iris._config.ItemSpacing.X, -- horizontal spacing between child widgets. VerticalAlignment: Enum.VerticalAlignment? = Enum.VerticalAlignment.Center -- how widgets vertically to each other. HorizontalAlignment: Enum.HorizontalAlignment? = Enum.HorizontalAlignment.Center -- how widgets are horizontally. }   "},{"title":"Group​","type":1,"pageTitle":"Format","url":"/Iris/api/Format#Group","content":"Widget HasChildren &lt;/&gt; Format.Group: Iris.Group Layout widget which contains its children as a single group. hasChildren = true hasState = false  "},{"title":"Tree","type":0,"sectionRef":"#","url":"/Iris/api/Tree","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#properties","content":" "},{"title":"Tree​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#Tree","content":"Widget HasChildren HasState &lt;/&gt; Tree.Tree: Iris.Tree A collapsable container for other widgets, to organise and hide widgets when not needed. The state determines whether the child widgets are visible or not. Clicking on the widget will collapse or uncollapse it. hasChildren: true hasState: true Arguments = { Text: string, SpanAvailWidth: boolean? = false, -- the tree title will fill all horizontal space to the end its parent container. NoIndent: boolean? = false -- the child widgets will not be indented underneath. } Events = { collapsed: () -&gt; boolean, uncollapsed: () -&gt; boolean, hovered: () -&gt; boolean } State = { isUncollapsed: State&lt;boolean&gt;? -- whether the widget is collapsed. }   "},{"title":"CollapsingHeader​","type":1,"pageTitle":"Tree","url":"/Iris/api/Tree#CollapsingHeader","content":"Widget HasChildren HasState &lt;/&gt; Tree.CollapsingHeader: Iris.CollapsingHeader The same as a Tree Widget, but with a larger title and clearer, used mainly for organsing widgets on the first level of a window. hasChildren: true hasState: true Arguments = { Text: string } Events = { collapsed: () -&gt; boolean, uncollapsed: () -&gt; boolean, hovered: () -&gt; boolean } State = { isUncollapsed: State&lt;boolean&gt;? -- whether the widget is collapsed. }  "},{"title":"Table","type":0,"sectionRef":"#","url":"/Iris/api/Table","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#properties","content":" "},{"title":"Table​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#Table","content":"Widget HasChildren &lt;/&gt; Table.Table: Iris.Table A layout widget which allows children to be displayed in configurable columns and rows. hasChildren = true hasState = false Arguments = { NumColumns = number, RowBg = boolean? = false, -- whether the row backgrounds alternate a background fill. BordersOuter = boolean? = false, BordersInner = boolean? = false, -- borders on each cell. } Events = { hovered: () -&gt; boolean }  "},{"title":"Functions​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#functions","content":" "},{"title":"NextColumn​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#NextColumn","content":"&lt;/&gt; Table.NextColumn() → () In a table, moves to the next available cell. if the current cell is in the last column, then the next cell will be the first column of the next row.  "},{"title":"SetColumnIndex​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#SetColumnIndex","content":"&lt;/&gt; Table.SetColumnIndex(index: number) → () In a table, directly sets the index of the column.  "},{"title":"NextRow​","type":1,"pageTitle":"Table","url":"/Iris/api/Table#NextRow","content":"&lt;/&gt; Table.NextRow() → () In a table, moves to the next available row, skipping cells in the previous column if the last cell wasn't in the last column "},{"title":"Window","type":0,"sectionRef":"#","url":"/Iris/api/Window","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#properties","content":" "},{"title":"Window​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#Window","content":"Widget HasChildren HasState &lt;/&gt; Window.Window: Iris.Window The top-level container for all other widgets to be created within. Can be moved and resized across the screen. Cannot contain embedded windows. Menus can be appended to windows creating a menubar. hasChildren = true hasState = true Arguments = { Title: string, NoTitleBar: boolean? = false, NoBackground: boolean? = false, -- the background behind the widget container. NoCollapse: boolean? = false, NoClose: boolean? = false, NoMove: boolean? = false, NoScrollbar: boolean? = false, -- the scrollbar if the window is too short for all widgets. NoResize: boolean? = false, NoNav: boolean? = false, -- unimplemented. NoMenu: boolean? -- whether the menubar will show if created. } Events = { opened: () -&gt; boolean, -- once when opened. closed: () -&gt; boolean, -- once when closed. collapsed: () -&gt; boolean, -- once when collapsed. uncollapsed: () -&gt; boolean, -- once when uncollapsed. hovered: () -&gt; boolean -- fires when the mouse hovers over any of the window. } States = { size = State&lt;Vector2&gt;? = Vector2.new(400, 300), position = State&lt;Vector2&gt;?, isUncollapsed = State&lt;boolean&gt;? = true, isOpened = State&lt;boolean&gt;? = true, scrollDistance = State&lt;number&gt;? -- vertical scroll distance, if too short. }   "},{"title":"Tooltip​","type":1,"pageTitle":"Window","url":"/Iris/api/Window#Tooltip","content":"Widget &lt;/&gt; Window.Tooltip: Iris.Tooltip Displays a text label next to the cursor Iris.Tooltip({&quot;My custom tooltip&quot;}) hasChildren = false hasState = false Arguments = { Text: string }  "},{"title":"Text","type":0,"sectionRef":"#","url":"/Iris/api/Text","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#properties","content":" "},{"title":"Text​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#Text","content":"Widget &lt;/&gt; Text.Text: Iris.Text A text label to display the text argument. The Wrapped argument will make the text wrap around if it is cut off by its parent. The Color argument will change the color of the text, by default it is defined in the configuration file. The RichText argument will hasChildren = false hasState = false Arguments = { Text: string, Wrapped: boolean? = [CONFIG] = false, -- whether the text will wrap around inside the parent container. If not specified, then equal to the config Color: Color3? = Iris._config.TextColor, -- the colour of the text. RichText: boolean? = [CONFIG] = false -- enable RichText. If not specified, then equal to the config } Events = { hovered: () -&gt; boolean }   "},{"title":"SeparatorText​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#SeparatorText","content":"Widget &lt;/&gt; Text.SeparatorText: Iris.SeparatorText Similar to Iris.Separator but with a text label to be used as a header when an Iris.Tree or Iris.CollapsingHeader is not appropriate. Visually a full width thin line with a text label clipping out part of the line. hasChildren = false hasState = false Arguments = { Text: string }   "},{"title":"InputText​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#InputText","content":"Widget HasState &lt;/&gt; Text.InputText: Iris.InputText A field which allows the user to enter text. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputText&quot;, TextHint: string? = &quot;&quot;, -- a hint to display when the text box is empty. ReadOnly: boolean? = false, MultiLine: boolean? = false } Events = { textChanged: () -&gt; boolean, -- whenever the textbox looses focus and a change was made. hovered: () -&gt; boolean } States = { text: State&lt;string&gt;? }   "},{"title":"TextWrapped​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#TextWrapped","content":"Widget deprecated in v2.0.0 &lt;/&gt; This was deprecated in v2.0.0 Use 'Text' with the Wrapped argument or change the config. Text.TextWrapped: Iris.Text An alias for Iris.Text with the Wrapped argument set to true, and the text will wrap around if cut off by its parent. hasChildren = false hasState = false Arguments = { Text: string, } Events = { hovered: () -&gt; boolean }   "},{"title":"TextColored​","type":1,"pageTitle":"Text","url":"/Iris/api/Text#TextColored","content":"Widget deprecated in v2.0.0 &lt;/&gt; This was deprecated in v2.0.0 Use 'Text' with the Color argument or change the config. Text.TextColored: Iris.Text An alias for Iris.Text with the color set by the Color argument. hasChildren = false hasState = false Arguments = { Text: string, Color: Color3 -- the colour of the text. } Events = { hovered: () -&gt; boolean }  "},{"title":"Combo","type":0,"sectionRef":"#","url":"/Iris/api/Combo","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#properties","content":" "},{"title":"Selectable​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#Selectable","content":"Widget HasState &lt;/&gt; Combo.Selectable: Iris.Selectable An object which can be selected. hasChildren = false hasState = true Arguments = { Text: string, Index: any, -- index of selectable value. NoClick: boolean? = false -- prevents the selectable from being clicked by the user. } Events = { selected: () -&gt; boolean, unselected: () -&gt; boolean, active: () -&gt; boolean, clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, hovered: () -&gt; boolean, } States = { index: State&lt;any&gt; -- a shared state between all selectables. }   "},{"title":"Combo​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#Combo","content":"Widget HasChildren HasState &lt;/&gt; Combo.Combo: Iris.Combo A selection box to choose a value from a range of values. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, closed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? }   "},{"title":"ComboArray​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#ComboArray","content":"Widget HasChildren HasState &lt;/&gt; Combo.ComboArray: Iris.Combo A selection box to choose a value from an array. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, closed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? } Extra = { selectionArray: { any } -- the array to generate a combo from. }   "},{"title":"ComboEnum​","type":1,"pageTitle":"Combo","url":"/Iris/api/Combo#ComboEnum","content":"Widget HasChildren HasState &lt;/&gt; Combo.ComboEnum: Iris.Combo A selection box to choose a value from an Enum. hasChildren = true hasState = true Arguments = { Text: string, NoButton: boolean? = false, -- hide the dropdown button. NoPreview: boolean? = false -- hide the preview field. } Events = { opened: () -&gt; boolean, closed: () -&gt; boolean, clicked: () -&gt; boolean, hovered: () -&gt; boolean } States = { index: State&lt;any&gt;, isOpened: State&lt;boolean&gt;? } Extra = { enumType: Enum -- the enum to generate a combo from. }  "},{"title":"Image","type":0,"sectionRef":"#","url":"/Iris/api/Image","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Image","url":"/Iris/api/Image#properties","content":" "},{"title":"Image​","type":1,"pageTitle":"Image","url":"/Iris/api/Image#Image","content":"Widget &lt;/&gt; Image.Image: Iris.Image An image widget for displaying an image given its texture ID and a size. The widget also supports Rect Offset and Size allowing cropping of the image and the rest of the ScaleType properties. Some of the arguments are only used depending on the ScaleType property, such as TileSize or Slice which will be ignored. hasChildren = false hasState = false Arguments = { Image: string, -- the texture asset id Size: UDim2, Rect: Rect? = Rect.new(), -- Rect structure which is used to determine the offset or size. An empty, zeroed rect is equivalent to nil ScaleType: Enum.ScaleType? = Enum.ScaleType.Stretch, -- used to determine whether the TileSize, SliceCenter and SliceScale arguments are used ResampleMode: Enum.ResampleMode? = Enum.ResampleMode.Default, TileSize: UDim2? = UDim2.fromScale(1, 1), -- only used if the ScaleType is set to Tile SliceCenter: Rect? = Rect.new(), -- only used if the ScaleType is set to Slice SliceScale: number? = 1 -- only used if the ScaleType is set to Slice } Events = { hovered: () -&gt; boolean }   "},{"title":"ImageButton​","type":1,"pageTitle":"Image","url":"/Iris/api/Image#ImageButton","content":"Widget &lt;/&gt; Image.ImageButton: Iris.ImageButton An image button widget for a button as an image given its texture ID and a size. The widget also supports Rect Offset and Size allowing cropping of the image, and the rest of the ScaleType properties. Supports all of the events of a regular button. hasChildren = false hasState = false Arguments = { Image: string, -- the texture asset id Size: UDim2, Rect: Rect? = Rect.new(), -- Rect structure which is used to determine the offset or size. An empty, zeroed rect is equivalent to nil ScaleType: Enum.ScaleType? = Enum.ScaleType.Stretch, -- used to determine whether the TileSize, SliceCenter and SliceScale arguments are used ResampleMode: Enum.ResampleMode? = Enum.ResampleMode.Default, TileSize: UDim2? = UDim2.fromScale(1, 1), -- only used if the ScaleType is set to Tile SliceCenter: Rect? = Rect.new(), -- only used if the ScaleType is set to Slice SliceScale: number? = 1 -- only used if the ScaleType is set to Slice } Events = { clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, -- when the control key is down and clicked. hovered: () -&gt; boolean }  "},{"title":"Menu","type":0,"sectionRef":"#","url":"/Iris/api/Menu","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#properties","content":" "},{"title":"MenuBar​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuBar","content":"Widget HasChildren &lt;/&gt; Menu.MenuBar: Iris.MenuBar Creates a MenuBar for the current window. Must be called directly under a Window and not within a child widget. info This does not create any menus, just tells the window that we going to add menus within. hasChildren = true hasState = false   "},{"title":"Menu​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#Menu","content":"Widget HasChildren HasState &lt;/&gt; Menu.Menu: Iris.Menu Creates an collapsable menu. If the Menu is created directly under a MenuBar, then the widget will be placed horizontally below the window title. If the menu Menu is created within another menu, then it will be placed vertically alongside MenuItems and display an arrow alongside. The opened menu will be a vertically listed box below or next to the button. info There are widgets which are designed for being parented to a menu whilst other happens to work. There is nothing preventing you from adding any widget as a child, but the behaviour is unexplained and not intended, despite allowed. hasChildren = true hasState = true Arguments = { Text: string -- menu text. } Events = { clicked: () -&gt; boolean, opened: () -&gt; boolean, -- once when opened. closed: () -&gt; boolean, -- once when closed. hovered: () -&gt; boolean } States = { isOpened: State&lt;boolean&gt;? -- whether the menu is open, including any sub-menus within. }   "},{"title":"MenuItem​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuItem","content":"Widget &lt;/&gt; Menu.MenuItem: Iris.MenuItem Creates a button within a menu. The optional KeyCode and ModiferKey arguments will show the keys next to the title, but will not bind any connection to them. You will need to do this yourself. hasChildren = false hasState = false Arguments = { Text: string, KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event. ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code. } Events = { clicked: () -&gt; boolean, hovered: () -&gt; boolean }   "},{"title":"MenuToggle​","type":1,"pageTitle":"Menu","url":"/Iris/api/Menu#MenuToggle","content":"Widget HasState &lt;/&gt; Menu.MenuToggle: Iris.MenuToggle Creates a togglable button within a menu. The optional KeyCode and ModiferKey arguments act the same as the MenuItem. It is not visually the same as a checkbox, but has the same functionality. hasChildren = false hasState = true Arguments = { Text: string, KeyCode: Enum.KeyCode? = nil, -- an optional keycode, does not actually connect an event. ModifierKey: Enum.ModifierKey? = nil -- an optional modifer key for the key code. } Events = { checked: () -&gt; boolean, -- once on check. unchecked: () -&gt; boolean, -- once on uncheck. hovered: () -&gt; boolean } States = { isChecked: State&lt;boolean&gt;? }  "},{"title":"State","type":0,"sectionRef":"#","url":"/Iris/api/State","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"State","url":"/Iris/api/State#types","content":" "},{"title":"State<T>​","type":1,"pageTitle":"State","url":"/Iris/api/State#State<T>","content":"&lt;/&gt; type State&lt;T&gt; = { ID: ID, value: T, get: (self) → T, set: ( self, newValue: T ) → T, onChange: ( self, callback: (newValue: T) → () ) → (), ConnectedWidgets: {[ID]: Widget}, ConnectedFunctions: {(newValue: T) → ()} }  "},{"title":"Functions​","type":1,"pageTitle":"State","url":"/Iris/api/State#functions","content":" "},{"title":"get<T>​","type":1,"pageTitle":"State","url":"/Iris/api/State#get<T>","content":"&lt;/&gt; State:get&lt;T&gt;() → T Returns the states current value.  "},{"title":"set<T>​","type":1,"pageTitle":"State","url":"/Iris/api/State#set<T>","content":"&lt;/&gt; State:set&lt;T&gt;(newValue: T) → T Allows the caller to assign the state object a new value, and returns the new value.  "},{"title":"onChange<T>​","type":1,"pageTitle":"State","url":"/Iris/api/State#onChange<T>","content":"&lt;/&gt; State:onChange&lt;T&gt;(callback: (newValue: T) → ()) → () Allows the caller to connect a callback which is called when the states value is changed. caution Calling :onChange() every frame will add a new function every frame. You must ensure you are only calling :onChange() once for each callback for the state's entire lifetime. "},{"title":"Basic","type":0,"sectionRef":"#","url":"/Iris/api/Basic","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#properties","content":" "},{"title":"Button​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#Button","content":"Widget &lt;/&gt; Basic.Button: Iris.Button A clickable button the size of the text with padding. Can listen to the clicked() event to determine if it was pressed. hasChildren = false hasState = false Arguments = { Text: string, Size: UDim2? = 0, } Events = { clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, -- when the control key is down and clicked. hovered: () -&gt; boolean }   "},{"title":"SmallButton​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#SmallButton","content":"Widget &lt;/&gt; Basic.SmallButton: Iris.SmallButton A smaller clickable button, the same as a Iris.Button but without padding. Can listen to the clicked() event to determine if it was pressed. hasChildren = false hasState = false Arguments = { Text: string, Size: UDim2? = 0, } Events = { clicked: () -&gt; boolean, rightClicked: () -&gt; boolean, doubleClicked: () -&gt; boolean, ctrlClicked: () -&gt; boolean, -- when the control key is down and clicked. hovered: () -&gt; boolean }   "},{"title":"Checkbox​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#Checkbox","content":"Widget HasState &lt;/&gt; Basic.Checkbox: Iris.Checkbox A checkable box with a visual tick to represent a boolean true or false state. hasChildren = false hasState = true Arguments = { Text: string } Events = { checked: () -&gt; boolean, -- once when checked. unchecked: () -&gt; boolean, -- once when unchecked. hovered: () -&gt; boolean } State = { isChecked = State&lt;boolean&gt;? -- whether the box is checked. }   "},{"title":"RadioButton​","type":1,"pageTitle":"Basic","url":"/Iris/api/Basic#RadioButton","content":"Widget HasState &lt;/&gt; Basic.RadioButton: Iris.RadioButton A circular selectable button, changing the state to its index argument. Used in conjunction with multiple other RadioButtons sharing the same state to represent one value from multiple options. hasChildren = false hasState = true Arguments = { Text: string, Index: any -- the state object is set to when clicked. } Events = { selected: () -&gt; boolean, unselected: () -&gt; boolean, active: () -&gt; boolean, -- if the state index equals the RadioButton's index. hovered: () -&gt; boolean } State = { index = State&lt;any&gt;? -- the state set by the index of a RadioButton. }  "},{"title":"Internal","type":0,"sectionRef":"#","url":"/Iris/api/Internal","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#properties","content":" "},{"title":"_cycleCoroutine​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_cycleCoroutine","content":"&lt;/&gt; Internal._cycleCoroutine: thread The thread which handles all connected functions. Each connection is within a pcall statement which prevents Iris from crashing and instead stopping at the error. "},{"title":"Functions​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#functions","content":" "},{"title":"_cycle​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_cycle","content":"&lt;/&gt; Internal._cycle() → () Called every frame to handle all of the widget management. Any previous frame data is ammended and everything updates.  "},{"title":"WidgetConstructor​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#WidgetConstructor","content":"&lt;/&gt; Internal.WidgetConstructor( type: string,-- name used to denote the widget class. widgetClass: Types.WidgetClass-- table of methods for the new widget. ) → () For each widget, a widget class is created which handles all the operations of a widget. This removes the class nature of widgets, and simplifies the available functions which can be applied to any widget. The widgets themselves are dumb tables containing all the data but no methods to handle any of the data apart from events.  "},{"title":"_Insert​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_Insert","content":"&lt;/&gt; Internal._Insert( widgetType:: string,-- name of widget class. arguments: {[string]: number},-- arguments of the widget. states: {[string]: States&lt;any&gt;}?-- states of the widget. ) → Widget-- the widget. Every widget is created through _Insert. An ID is generated based on the line of the calling code and is used to find the previous frame widget if it exists. If no widget exists, a new one is created.  "},{"title":"_GenNewWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_GenNewWidget","content":"&lt;/&gt; Internal._GenNewWidget( widgetType: string, arguments: {[string]: any},-- arguments of the widget. states: {[string]: State&lt;any&gt;}?,-- states of the widget. ID: ID-- id of the new widget. Determined in Internal._Insert ) → Widget-- the newly created widget. All widgets are created as tables with properties. The widget class contains the functions to create the UI instances and update the widget or change state.  "},{"title":"_ContinueWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_ContinueWidget","content":"&lt;/&gt; Internal._ContinueWidget( ID: ID,-- id of the widget. widgetType: string ) → Widget-- the widget. Since the widget has already been created this frame, we can just add it back to the stack. There is no checking of arguments or states. Basically equivalent to the end of Internal._Insert.  "},{"title":"_DiscardWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_DiscardWidget","content":"&lt;/&gt; Internal._DiscardWidget(widgetToDiscard: Widget) → () Destroys the widget instance and updates any parent. This happens if the widget was not called in the previous frame. There is no code which needs to update any widget tables since they are already reset at the start before discarding happens.  "},{"title":"_widgetState​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_widgetState","content":"&lt;/&gt; Internal._widgetState( thisWidget: Widget,-- widget the state belongs to. stateName: string, initialValue: any ) → State&lt;any&gt;-- the state for the widget. Connects the state to the widget. If no state exists then a new one is created. Called for every state in every widget if the user does not provide a state.  "},{"title":"_EventCall​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_EventCall","content":"&lt;/&gt; Internal._EventCall( thisWidget: Widget, evetName: string ) → boolean-- the value of the event. A wrapper for any event on any widget. Automatically, Iris does not initialize events unless they are explicitly called so in the first frame, the event connections are set up. Every event is a function which returns a boolean.  "},{"title":"_GetParentWidget​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_GetParentWidget","content":"&lt;/&gt; Internal._GetParentWidget() → Widget-- the parent widget Returns the parent widget of the currently active widget, based on the stack depth.  "},{"title":"_getID​","type":1,"pageTitle":"Internal","url":"/Iris/api/Internal#_getID","content":"&lt;/&gt; Internal._getID( levelsToIgnore: number-- used to skip over internal calls to _getID. ) → ID Generates a unique ID for each widget which is based on the line that the widget is created from. This ensures that the function is heuristic and always returns the same id for the same widget. "},{"title":"Drag","type":0,"sectionRef":"#","url":"/Iris/api/Drag","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#properties","content":" "},{"title":"DragNum​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragNum","content":"Widget HasState &lt;/&gt; Drag.DragNum: Iris.DragNum A field which allows the user to click and drag their cursor to enter a number. You can ctrl + click to directly input a number, like InputNum. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragNum&quot;, Increment: number? = nil, Min: number? = nil, Max: number? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragVector2​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragVector2","content":"Widget HasState &lt;/&gt; Drag.DragVector2: Iris.DragVector2 A field which allows the user to click and drag their cursor to enter a Vector2. You can ctrl + click to directly input a Vector2, like InputVector2. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragVector2&quot;, Increment: Vector2? = nil, Min: Vector2? = nil, Max: Vector2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragVector3​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragVector3","content":"Widget HasState &lt;/&gt; Drag.DragVector3: Iris.DragVector3 A field which allows the user to click and drag their cursor to enter a Vector3. You can ctrl + click to directly input a Vector3, like InputVector3. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragVector3&quot;, Increment: Vector3? = nil, Min: Vector3? = nil, Max: Vector3? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragUDim​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragUDim","content":"Widget HasState &lt;/&gt; Drag.DragUDim: Iris.DragUDim A field which allows the user to click and drag their cursor to enter a UDim. You can ctrl + click to directly input a UDim, like InputUDim. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragUDim&quot;, Increment: UDim? = nil, Min: UDim? = nil, Max: UDim? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragUDim2​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragUDim2","content":"Widget HasState &lt;/&gt; Drag.DragUDim2: Iris.DragUDim2 A field which allows the user to click and drag their cursor to enter a UDim2. You can ctrl + click to directly input a UDim2, like InputUDim2. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragUDim2&quot;, Increment: UDim2? = nil, Min: UDim2? = nil, Max: UDim2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"DragRect​","type":1,"pageTitle":"Drag","url":"/Iris/api/Drag#DragRect","content":"Widget HasState &lt;/&gt; Drag.DragRect: Iris.DragRect A field which allows the user to click and drag their cursor to enter a Rect. You can ctrl + click to directly input a Rect, like InputRect. You can hold Shift to increase speed, and Alt to decrease speed when dragging. hasChildren = false hasState = true Arguments = { Text: string? = &quot;DragRect&quot;, Increment: Rect? = nil, Min: Rect? = nil, Max: Rect? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Slider","type":0,"sectionRef":"#","url":"/Iris/api/Slider","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#properties","content":" "},{"title":"SliderNum​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderNum","content":"Widget HasState &lt;/&gt; Slider.SliderNum: Iris.SliderNum A field which allows the user to slide a grip to enter a number within a range. You can ctrl + click to directly input a number, like InputNum. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderNum&quot;, Increment: number? = 1, Min: number? = 0, Max: number? = 100, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderVector2​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderVector2","content":"Widget HasState &lt;/&gt; Slider.SliderVector2: Iris.SliderVector2 A field which allows the user to slide a grip to enter a Vector2 within a range. You can ctrl + click to directly input a Vector2, like InputVector2. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderVector2&quot;, Increment: Vector2? = { 1, 1 }, Min: Vector2? = { 0, 0 }, Max: Vector2? = { 100, 100 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderVector3​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderVector3","content":"Widget HasState &lt;/&gt; Slider.SliderVector3: Iris.SliderVector3 A field which allows the user to slide a grip to enter a Vector3 within a range. You can ctrl + click to directly input a Vector3, like InputVector3. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderVector3&quot;, Increment: Vector3? = { 1, 1, 1 }, Min: Vector3? = { 0, 0, 0 }, Max: Vector3? = { 100, 100, 100 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderUDim​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderUDim","content":"Widget HasState &lt;/&gt; Slider.SliderUDim: Iris.SliderUDim A field which allows the user to slide a grip to enter a UDim within a range. You can ctrl + click to directly input a UDim, like InputUDim. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderUDim&quot;, Increment: UDim? = { 0.01, 1 }, Min: UDim? = { 0, 0 }, Max: UDim? = { 1, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderUDim2​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderUDim2","content":"Widget HasState &lt;/&gt; Slider.SliderUDim2: Iris.SliderUDim2 A field which allows the user to slide a grip to enter a UDim2 within a range. You can ctrl + click to directly input a UDim2, like InputUDim2. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderUDim2&quot;, Increment: UDim2? = { 0.01, 1, 0.01, 1 }, Min: UDim2? = { 0, 0, 0, 0 }, Max: UDim2? = { 1, 960, 1, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"SliderRect​","type":1,"pageTitle":"Slider","url":"/Iris/api/Slider#SliderRect","content":"Widget HasState &lt;/&gt; Slider.SliderRect: Iris.SliderRect A field which allows the user to slide a grip to enter a Rect within a range. You can ctrl + click to directly input a Rect, like InputRect. hasChildren = false hasState = true Arguments = { Text: string? = &quot;SliderRect&quot;, Increment: Rect? = { 1, 1, 1, 1 }, Min: Rect? = { 0, 0, 0, 0 }, Max: Rect? = { 960, 960, 960, 960 }, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Input","type":0,"sectionRef":"#","url":"/Iris/api/Input","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#properties","content":" "},{"title":"InputNum​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputNum","content":"Widget HasState &lt;/&gt; Input.InputNum: Iris.InputNum An input box for numbers. The number can be either an integer or a float. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputNum&quot;, Increment: number? = nil, Min: number? = nil, Max: number? = nil, Format: string? | { string }? = [DYNAMIC], -- Iris will dynamically generate an approriate format. NoButtons: boolean? = false -- whether to display + and - buttons next to the input box. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputVector2​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputVector2","content":"Widget HasState &lt;/&gt; Input.InputVector2: Iris.InputVector2 An input box for Vector2. The numbers can be either integers or floats. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputVector2&quot;, Increment: Vector2? = nil, Min: Vector2? = nil, Max: Vector2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputVector3​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputVector3","content":"Widget HasState &lt;/&gt; Input.InputVector3: Iris.InputVector3 An input box for Vector3. The numbers can be either integers or floats. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputVector3&quot;, Increment: Vector3? = nil, Min: Vector3? = nil, Max: Vector3? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Vector3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputUDim​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputUDim","content":"Widget HasState &lt;/&gt; Input.InputUDim: Iris.InputUDim An input box for UDim. The Scale box will be a float and the Offset box will be an integer, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputUDim&quot;, Increment: UDim? = nil, Min: UDim? = nil, Max: UDim? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputUDim2​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputUDim2","content":"Widget HasState &lt;/&gt; Input.InputUDim2: Iris.InputUDim2 An input box for UDim2. The Scale boxes will be floats and the Offset boxes will be integers, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputUDim2&quot;, Increment: UDim2? = nil, Min: UDim2? = nil, Max: UDim2? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;UDim2&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputRect​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputRect","content":"Widget HasState &lt;/&gt; Input.InputRect: Iris.InputRect An input box for Rect. The numbers will default to integers, unless specified differently. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputRect&quot;, Increment: Rect? = nil, Min: Rect? = nil, Max: Rect? = nil, Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { number: State&lt;Rect&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputColor3​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputColor3","content":"Widget HasState &lt;/&gt; Input.InputColor3: Iris.InputColor3 An input box for Color3. The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1. Input can also be done using HSV instead of the default RGB. If no format argument is provided then a default R, G, B or H, S, V prefix is applied. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputColor3&quot;, UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255. UseHSV: boolean? = false, -- input using HSV instead. Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { color: State&lt;Color3&gt;?, editingText: State&lt;boolean&gt;? }   "},{"title":"InputColor4​","type":1,"pageTitle":"Input","url":"/Iris/api/Input#InputColor4","content":"Widget HasState &lt;/&gt; Input.InputColor4: Iris.InputColor4 An input box for Color4. Color4 is a combination of Color3 and a fourth transparency argument. It has two states for this purpose. The input boxes are draggable between 0 and 255 or if UseFloats then between 0 and 1. Input can also be done using HSV instead of the default RGB. If no format argument is provided then a default R, G, B, T or H, S, V, T prefix is applied. hasChildren = false hasState = true Arguments = { Text: string? = &quot;InputColor4&quot;, UseFloats: boolean? = false, -- constrain the values between floats 0 and 1 or integers 0 and 255. UseHSV: boolean? = false, -- input using HSV instead. Format: string? | { string }? = [DYNAMIC] -- Iris will dynamically generate an approriate format. } Events = { numberChanged: () -&gt; boolean, hovered: () -&gt; boolean } States = { color: State&lt;Color3&gt;?, transparency: State&lt;number&gt;?, editingText: State&lt;boolean&gt;? }  "},{"title":"Creating Custom Widgets","type":0,"sectionRef":"#","url":"/Iris/docs/creatingCustomWidgets","content":"","keywords":""},{"title":"Widget Construction​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#widget-construction","content":"For Instance, this is the call to Iris.WidgetConstructor for the Iris.Text widget: Iris.WidgetConstructor(&quot;Text&quot;, { hasState = false, hasChildren = false, Args = { [&quot;Text&quot;] = 1 }, Events { [&quot;hovered&quot;] = { ... } } Generate = function(thisWidget) local Text = Instance.new(&quot;TextLabel&quot;) ... return Text end, Update = function(thisWidget) ... end, Discard = function(thisWidget) thisWidget.Instance:Destroy() end })  The first argument, type: string, specifies a name for the widget. The second argument is the widget class. The methods which a widget class has depends on the value of hasState and hasChildren. Every widget class should specify if it hasState and hasChildren. The example widget, a text label, has no state, and it does not contain other widgets, so both are false. Every widget must have the following functions: All Widgets\tWidgets with State\tWidgets with ChildrenGenerate\tGenerateState\tChildAdded Update\tUpdateState\tChildDiscarded (optional) Discard Args Events  "},{"title":"Generate​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#generate","content":"Generate is called when a widget is first instantiated. It should create all the instances and properly adjust them to fit the config properties. Generate is also called when style properties change. Generate should return the instance which acts as the root of the widget. (what should be parented to the parents designated Instance) "},{"title":"Update​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#update","content":"Update is called only after instantiation and when widget arguments have changed. For instance, in Iris.Text Update = function(thisWidget) local Text = thisWidget.Instance if thisWidget.arguments.Text == nil then error(&quot;Iris.Text Text Argument is required&quot;, 5) end Text.Text = thisWidget.arguments.Text end  "},{"title":"Discard​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#discard","content":"Discard is called when the widget stops being displayed. In most cases the function body should resemble this: Discard = function(thisWidget) thisWidget.Instance:Destroy() end  "},{"title":"Events​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#events","content":"Events is a table, not a method. It contains all of the possible events which a widget can have. Lets look at the hovered event as an example. [&quot;hovered&quot;] = { [&quot;Init&quot;] = function(thisWidget) local hoveredGuiObject = thisWidget.Instance thisWidget.isHoveredEvent = false hoveredGuiObject.MouseEnter:Connect(function() thisWidget.isHoveredEvent = true end) hoveredGuiObject.MouseLeave:Connect(function() thisWidget.isHoveredEvent = false end) end, [&quot;Get&quot;] = function(thisWidget) return thisWidget.isHoveredEvent end }  Every event has 2 methods, Init and Get.Init is called when a widget first polls the value of an event. Because of this, you can instantiate events and variables for an event to only widgets which need it.Get is the actual function which is called by the call to an event (like Button.hovered()), it should return the event value. "},{"title":"Args​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#args","content":"Args is a table, not a method. It enumerates all of the possible arguments which may be passed as arguments into the widget. The order of the tables indicies indicate which position the Argument will be interpreted as. For instance, in Iris.Text: Args = { [&quot;Text&quot;] = 1 }  when a Text widget is generated, the first index of the Arguments table will be interpreted as the 'Text' parameter Iris.Text({[1] = &quot;Hello&quot;}) -- same result Iris.Text({&quot;Hello&quot;})  the Update function can retrieve arguments from thisWidget.arguments, such as thisWidget.arguments.Text "},{"title":"GenerateState​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#generatestate","content":"GenerateState is called when the widget is first Instantiated, It should generate any state objects which weren't passed as a state by the user. For Instance, in Iris.Checkbox: GenerateState = function(thisWidget) if thisWidget.state.isChecked == nil then thisWidget.state.isChecked = Iris._widgetState(thisWidget, &quot;checked&quot;, false) end end  "},{"title":"UpdateState​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#updatestate","content":"UpdateState is called whenever ANY state objects are updated, using its :set() method. For instance, in Iris.Checkbox: UpdateState = function(thisWidget) local Checkbox = thisWidget.Instance.CheckboxBox if thisWidget.state.isChecked.value then Checkbox.Text = ICONS.CHECK_MARK thisWidget.events.checked = true else Checkbox.Text = &quot;&quot; thisWidget.events.unchecked = true end end  caution calling :set() to any of a widget's own state objects inside of UpdateState may cause an infinite loop of state updates. UpdateState should avoid calling :set(). "},{"title":"ChildAdded​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#childadded","content":"ChildAdded is called when a widget is first Initiated and is a child of the widget. ChildAdded should return the Instance which the Child will be parented to. "},{"title":"ChildDiscarded​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#childdiscarded","content":"ChildDiscarded is called when a widget is Discarded and is a child of the widget. ChildDiscarded is optional. "},{"title":"Widget Usage​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#widget-usage","content":"To use this widget once it has been constructed, you can use: Iris.Internal._Insert(&quot;Text&quot;, {&quot;Sampele text&quot;}, nil) -- &quot;Text&quot; argument and no state  This is the same as calling any other widget but requires the widget name as passed to Iris.WidgetConstructor() as the first argument.  "},{"title":"When does a widget need to have state?​","type":1,"pageTitle":"Creating Custom Widgets","url":"/Iris/docs/creatingCustomWidgets#when-does-a-widget-need-to-have-state","content":"State should only be used by widgets when there are properties which are able to be set by BOTH the widget, and by the user's code. For Instance, Iris.Window has a state, size. This field can be changed by the user's code, to adjust or initiate the size, and the widget also changes the size when it is resized. If the window was never able to change the size property, such as if there were no resize feature, then instead it should be an argument. This table demonstrates the relation between User / Widget permissions, and where the field should belong inside the widget class.  "},{"title":"Iris","type":0,"sectionRef":"#","url":"/Iris/api/Iris","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#types","content":" "},{"title":"ID​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ID","content":"&lt;/&gt; type ID = string   "},{"title":"Widget​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Widget","content":"&lt;/&gt; type Widget = { ID: ID, type: string, lastCycleTick: number, parentWidget: Widget, Instance: GuiObject , ZIndex: number, arguments: {[string]: any} }  "},{"title":"Properties​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#properties","content":" "},{"title":"Disabled​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Disabled","content":"&lt;/&gt; Iris.Disabled: boolean While Iris.Disabled is true, execution of Iris and connected functions will be paused. The widgets are not destroyed, they are just frozen so no changes will happen to them.  "},{"title":"Args​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Args","content":"&lt;/&gt; Iris.Args: {[string]: {[string]: any}} Provides a list of every possible Argument for each type of widget to it's index. For instance, Iris.Args.Window.NoResize. The Args table is useful for using widget Arguments without remembering their order. Iris.Window({&quot;My Window&quot;, [Iris.Args.Window.NoResize] = true})   "},{"title":"TemplateConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#TemplateConfig","content":"&lt;/&gt; Iris.TemplateConfig: {[string]: {[string]: any}} TemplateConfig provides a table of default styles and configurations which you may apply to your UI. "},{"title":"Functions​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#functions","content":" "},{"title":"SetFocusedWindow​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#SetFocusedWindow","content":"&lt;/&gt; Iris.SetFocusedWindow( window: Types.Window-- the window to focus. ) → () Sets the focused window to the window provided, which brings it to the front and makes it active.  "},{"title":"Init​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Init","content":"&lt;/&gt; Iris.Init( parentInstance: Instance? ,-- where Iris will place widgets UIs under, defaulting to PlayerGui eventConnection: (RBXScriptSignal | () → () | false)?-- the event to determine an Iris cycle, defaulting to [Heartbeat] ) → Iris Initializes Iris and begins rendering. Can only be called once. See Iris.Shutdown to stop Iris, or Iris.Disabled to temporarily disable Iris. Once initialized, Iris:Connect can be used to create a widget. If the eventConnection is false then Iris will not create a cycle loop and the user will need to call Internal._cycle every frame.  "},{"title":"Shutdown​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Shutdown","content":"&lt;/&gt; Iris.Shutdown() → () Shuts Iris down. This can only be called once, and Iris cannot be started once shut down.  "},{"title":"Append​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Append","content":"&lt;/&gt; Iris.Append( userInstance: GuiObject -- the Roblox Instance to insert into Iris ) → () Inserts any Roblox Instance into Iris. The parent of the inserted instance can either be determined by the _config.Parent property or by the current parent widget from the stack.  "},{"title":"End​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#End","content":"&lt;/&gt; Iris.End() → () Marks the end of any widgets which contain children. For example: -- Widgets placed here **will not** be inside the tree Iris.Text({&quot;Above and outside the tree&quot;}) -- A Tree widget can contain children. -- We must therefore remember to call `Iris.End()` Iris.Tree({&quot;My First Tree&quot;}) -- Widgets placed here **will** be inside the tree Iris.Text({&quot;Tree item 1&quot;}) Iris.Text({&quot;Tree item 2&quot;}) Iris.End() -- Widgets placed here **will not** be inside the tree Iris.Text({&quot;Below and outside the tree&quot;}) Caution: Error Seeing the error Callback has too few calls to Iris.End() or Callback has too many calls to Iris.End()? Using the wrong amount of Iris.End() calls in your code will lead to an error. Each widget called which might have children should be paired with a call to Iris.End(), even if the Widget doesnt currently have any children.  "},{"title":"ForceRefresh​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ForceRefresh","content":"&lt;/&gt; Iris.ForceRefresh() → () Destroys and regenerates all instances used by Iris. Useful if you want to propogate state changes. Caution: Performance Because this function Deletes and Initializes many instances, it may cause performance issues when used with many widgets. In no case should it be called every frame.  "},{"title":"UpdateGlobalConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#UpdateGlobalConfig","content":"&lt;/&gt; Iris.UpdateGlobalConfig( deltaStyle: {[string]: any}-- a table containing the changes in style ex: {ItemWidth = UDim.new(0, 100)} ) → () Customizes the configuration which every widget will inherit from. It can be used along with Iris.TemplateConfig to easily swap styles, for example: Iris.UpdateGlobalConfig(Iris.TemplateConfig.colorLight) -- use light theme Caution: Performance This function internally calls Iris.ForceRefresh so that style changes are propogated. As such, it may cause performance issues when used with many widgets. In no case should it be called every frame.  "},{"title":"PushConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PushConfig","content":"&lt;/&gt; Iris.PushConfig( deltaStyle: {[string]: any}-- a table containing the changes in style ex: {ItemWidth = UDim.new(0, 100)} ) → () Allows cascading of a style by allowing styles to be locally and hierarchically applied. Each call to Iris.PushConfig must be paired with a call to Iris.PopConfig, for example: Iris.Text({&quot;boring text&quot;}) Iris.PushConfig({TextColor = Color3.fromRGB(128, 0, 256)}) Iris.Text({&quot;Colored Text!&quot;}) Iris.PopConfig() Iris.Text({&quot;boring text&quot;})   "},{"title":"PopConfig​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PopConfig","content":"&lt;/&gt; Iris.PopConfig() → () Ends a Iris.PushConfig style. Each call to Iris.PopConfig should match a call to Iris.PushConfig.  "},{"title":"PushId​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PushId","content":"&lt;/&gt; Iris.PushId( id: ID-- custom id ) → () Sets the id discriminator for the next widgets. Use Iris.PopId to remove it.  "},{"title":"PopID​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#PopID","content":"&lt;/&gt; Iris.PopID() → () Removes the id discriminator set by Iris.PushId.  "},{"title":"SetNextWidgetID​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#SetNextWidgetID","content":"&lt;/&gt; Iris.SetNextWidgetID( id: ID-- custom id. ) → () Sets the id for the next widget. Useful for using Iris.Append on the same widget. Iris.SetNextWidgetId(&quot;demo_window&quot;) Iris.Window({ &quot;Window&quot; }) Iris.Text({ &quot;Text one placed here.&quot; }) Iris.End() -- later in the code Iris.SetNextWidgetId(&quot;demo_window&quot;) Iris.Window() Iris.Text({ &quot;Text two placed here.&quot; }) Iris.End() -- both text widgets will be placed under the same window despite being called separately.   "},{"title":"State<T>​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#State<T>","content":"State &lt;/&gt; Iris.State&lt;T&gt;( initialValue: T-- the initial value for the state ) → State&lt;T&gt; Constructs a new State object. Subsequent ID calls will return the same object. info Iris.State allows you to create &quot;references&quot; to the same value while inside your UI drawing loop. For example: Iris:Connect(function() local myNumber = 5 myNumber = myNumber + 1 Iris.Text({&quot;The number is: &quot; .. myNumber}) end) This is problematic. Each time the function is called, a new myNumber is initialized, instead of retrieving the old one. The above code will always display 6. Iris.State solves this problem: Iris:Connect(function() local myNumber = Iris.State(5) myNumber:set(myNumber:get() + 1) Iris.Text({&quot;The number is: &quot; .. myNumber}) end) In this example, the code will work properly, and increment every frame.  "},{"title":"WeakState<T>​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#WeakState<T>","content":"State &lt;/&gt; Iris.WeakState&lt;T&gt;( initialValue: T-- the initial value for the state ) → State&lt;T&gt; Constructs a new state object, subsequent ID calls will return the same object, except all widgets connected to the state are discarded, the state reverts to the passed initialValue  "},{"title":"VariableState<T>​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#VariableState<T>","content":"State &lt;/&gt; Iris.VariableState&lt;T&gt;( variable: T,-- the variable to track callback: (T) → ()-- a function which sets the new variable locally ) → State&lt;T&gt; Returns a state object linked to a local variable. The passed variable is used to check whether the state object should update. The callback method is used to change the local variable when the state changes. The existence of such a function is to make working with local variables easier. Since Iris cannot directly manipulate the memory of the variable, like in C++, it must instead rely on the user updating it through the callback provided. Additionally, because the state value is not updated when created or called we cannot return the new value back, instead we require a callback for the user to update. local myNumber = 5 local state = Iris.VariableState(myNumber, function(value) myNumber = value end) Iris.DragNum({ &quot;My number&quot; }, { number = state }) This is how Dear ImGui does the same in C++ where we can just provide the memory location to the variable which is then updated directly. static int myNumber = 5; ImGui::DragInt(&quot;My number&quot;, &amp;myNumber); // Here in C++, we can directly pass the variable. Update Order If the variable and state value are different when calling this, the variable value takes precedence. Therefore, if you update the state using state.value = ... then it will be overwritten by the variable value. You must use state:set(...) if you want the variable to update to the state's value.  "},{"title":"TableState<K, V>​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#TableState<K, V>","content":"State &lt;/&gt; Iris.TableState&lt;K, V&gt;( table: {[K]: V},-- the table containing the value key: K,-- the key to the value in table callback: ((newValue: V) → false?)?-- a function called when the state is changed ) → State&lt;V&gt; Similar to Iris.VariableState but takes a table and key to modify a specific value and a callback to determine whether to update the value. The passed table and key are used to check the value. The callback is called when the state changes value and determines whether we update the table. This is useful if we want to monitor a table value which needs to call other functions when changed. Since tables are pass-by-reference, we can modify the table anywhere and it will update all other instances. Therefore, we don't need a callback by default. local data = { myNumber = 5 } local state = Iris.TableState(data, &quot;myNumber&quot;) Iris.DragNum({ &quot;My number&quot; }, { number = state }) Here the data._started should never be updated directly, only through the toggle function. However, we still want to monitor the value and be able to change it. Therefore, we use the callback to toggle the function for us and prevent Iris from updating the table value by returning false. local data ={ _started = false } local function toggle(enabled: boolean) data._started = enabled if data._started then start(...) else stop(...) end end local state = Iris.TableState(data, &quot;_started&quot;, function(stateValue: boolean) toggle(stateValue) return false end) Iris.Checkbox({ &quot;Started&quot; }, { isChecked = state }) Update Order If the table value and state value are different when calling this, the table value value takes precedence. Therefore, if you update the state using state.value = ... then it will be overwritten by the table value. You must use state:set(...) if you want the table value to update to the state's value.  "},{"title":"ComputedState<T, U>​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ComputedState<T, U>","content":"&lt;/&gt; Iris.ComputedState&lt;T, U&gt;( firstState: State&lt;T&gt;,-- State to bind to. onChangeCallback: (firstValue: T) → U-- callback which should return a value transformed from the firstState value ) → State&lt;U&gt; Constructs a new State object, but binds its value to the value of another State. info A common use case for this constructor is when a boolean State needs to be inverted: Iris.ComputedState(otherState, function(newValue) return not newValue end)   "},{"title":"ShowDemoWindow​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#ShowDemoWindow","content":"&lt;/&gt; Iris.ShowDemoWindow() → () ShowDemoWindow is a function which creates a Demonstration window. this window contains many useful utilities for coders, and serves as a refrence for using each part of the library. Ideally, the DemoWindow should always be available in your UI. It is the same as any other callback you would connect to Iris using Iris.Connect Iris:Connect(Iris.ShowDemoWindow)   "},{"title":"Connect​","type":1,"pageTitle":"Iris","url":"/Iris/api/Iris#Connect","content":"&lt;/&gt; Iris:Connect( callback: () → ()-- the callback containg the Iris code ) → () → ()-- call to disconnect it Connects a function which will execute every Iris cycle. Iris.Init must be called before connecting. A cycle is determined by the eventConnection passed to Iris.Init (default to RunService.Heartbeat). Multiple callbacks can be added to Iris from many different scripts or modules. "}]