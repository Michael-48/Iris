"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6857],{62643:e=>{e.exports=JSON.parse('{"functions":[{"name":"get<T>","desc":"Returns the states current value.\\n    ","params":[],"returns":[{"desc":"","lua_type":"T"}],"function_type":"method","source":{"line":129,"path":"lib/Internal.lua"}},{"name":"set<T>","desc":"Allows the caller to assign the state object a new value, and returns the new value.\\n    ","params":[{"name":"newValue","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"T"}],"function_type":"method","source":{"line":141,"path":"lib/Internal.lua"}},{"name":"onChange<T>","desc":"Allows the caller to connect a callback which is called when the states value is changed.\\n\\n:::caution\\nCalling `:onChange()` every frame will add a new function every frame.\\nYou must ensure you are only calling `:onChange()` once for each callback for the state\'s entire lifetime.\\n:::\\n    ","params":[{"name":"callback","desc":"","lua_type":"(newValue: T) -> ()"}],"returns":[],"function_type":"method","source":{"line":169,"path":"lib/Internal.lua"}}],"properties":[],"types":[{"name":"State<T>","desc":"","lua_type":"{ ID: ID, value: T, get: (self) -> T, set: (self, newValue: T) -> T, onChange: (self, callback: (newValue: T) -> ()) -> (), ConnectedWidgets: { [ID]: Widget }, ConnectedFunctions: { (newValue: T) -> () } }","source":{"line":11,"path":"lib/WidgetTypes.lua"}}],"name":"State","desc":"This class wraps a value in getters and setters, its main purpose is to allow primatives to be passed as objects.\\nConstructors for this class are available in [Iris]\\n\\n```lua\\nlocal state = Iris.State(0) -- we initialise the state with a value of 0\\n\\n-- these are equivalent. Ideally you should use `:get()` and ignore `.value`.\\nprint(state:get())\\nprint(state.value)\\n\\nstate:set(state:get() + 1) -- increments the state by getting the current value and adding 1.\\n\\nstate:onChange(function(newValue)\\n    print(`The value of the state is now: {newValue}`)\\nend)\\n```\\n\\n:::caution\\nNever call `:set()` on a state when inside the `:onChange()` callback of the same state. This will cause a continous callback.\\n\\nNever chain states together so that each state changes the value of another state in a cyclic nature. This will cause a continous callback.\\n:::\\n    ","source":{"line":119,"path":"lib/Internal.lua"}}')}}]);